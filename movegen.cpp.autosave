#include "movegen.h"

moveGen::moveGen()
{

}

//pawn moves
std::string moveGen::possibleWP(U64 wpawns, U64 EmptyTiles, U64 blackking)
{
    std::string list= "";

    //forward one
    U64 PAWN_MOVES = northOne(wpawns) & EmptyTiles;
    U64 i = PAWN_MOVES &~ (PAWN_MOVES-1);

    while(i != 0){
        int index = trailingZeros(i);
        list+=index%8;
        list+=index/8+1;
        list+=index%8;
        list+=index/8;
        PAWN_MOVES &= ~i;
        i= PAWN_MOVES & ~(PAWN_MOVES-1);
    }


    //forward two
    PAWN_MOVES = (wpawns>>16) & EmptyTiles &(EmptyTiles>>8) &rank4;
    i = PAWN_MOVES &~ (PAWN_MOVES-1);

    while(i != 0){
        int index = trailingZeros(i);
        list+=index%8;
        list+=index/8+2;
        list+=index%8;
        list+=index/8;
        PAWN_MOVES &= ~i;
        i= PAWN_MOVES & ~(PAWN_MOVES-1);
    }


    //capture right
    PAWN_MOVES = noEaOne(wpawns) & BBBlackPieces & ~blackking;
    i = PAWN_MOVES &~ (PAWN_MOVES-1);

    while(i != 0){
        int index = trailingZeros(i);
        list+=index%8-1;
        list+=index/8+1;
        list+=index%8;
        list+=index/8;
        PAWN_MOVES &= ~i;
        i= PAWN_MOVES & ~(PAWN_MOVES-1);
    }


    //capture left
    PAWN_MOVES = noWeOne(wpawns) & BBBlackPieces & ~blackking;
    i = PAWN_MOVES &~ (PAWN_MOVES-1);

    while(i != 0){
        int index = trailingZeros(i);
        list+=index%8+1;
        list+=index/8+1;
        list+=index%8;
        list+=index/8;
        PAWN_MOVES &= ~i;
        i= PAWN_MOVES & ~(PAWN_MOVES-1);
    }


//Pawn promotions moving forward one
    PAWN_MOVES = northOne(wpawns) & EmptyTiles & rank8;
    i = PAWN_MOVES &~ (PAWN_MOVES-1);

    while(i != 0){
        int index = trailingZeros(i);
        list+=index%8;
        list+=index/8+1;
        list+="F";
        list+="Q";
        PAWN_MOVES &= ~i;
        i= PAWN_MOVES & ~(PAWN_MOVES-1);
    }

//pawn capture promotions
    //capture right
    PAWN_MOVES = noEaOne(wpawns) & BBBlackPieces & ~blackking & rank8;
    i = PAWN_MOVES &~ (PAWN_MOVES-1);

    while(i != 0){
        int index = trailingZeros(i);
        list+=index%8-1;
        list+=index/8+1;
        list+=index%8;
        list+="Q";
        PAWN_MOVES &= ~i;
        i= PAWN_MOVES & ~(PAWN_MOVES-1);
    }


    //capture left
    PAWN_MOVES = noWeOne(wpawns) & BBBlackPieces & ~blackking & rank8;
    i = PAWN_MOVES &~ (PAWN_MOVES-1);

    while(i != 0){
        int index = trailingZeros(i);
        list+=index%8+1;
        list+=index/8+1;
        list+=index%8;
        list+="Q";
        PAWN_MOVES &= ~i;
        i= PAWN_MOVES & ~(PAWN_MOVES-1);
    }

    return list;
}

std::string moveGen::possibleBP(U64 bpawns, U64 EmptyTiles, U64 whiteking)
{
    std::string list= "";

    //forward one
    U64 PAWN_MOVES = southOne(bpawns) & EmptyTiles;   
    U64 i = PAWN_MOVES &~ (PAWN_MOVES-1);

    while(i != 0){
        int index = trailingZeros(i);
        list+=index%8;
        list+=index/8-1;
        list+=index%8;
        list+=index/8;
        PAWN_MOVES &= ~i;
        i= PAWN_MOVES & ~(PAWN_MOVES-1);

    }

    //forward two
    PAWN_MOVES = (bpawns<<16) & EmptyTiles &(EmptyTiles<<8) & rank5;
    i = PAWN_MOVES &~ (PAWN_MOVES-1);

    while(i != 0){
        int index = trailingZeros(i);
        list+=index%8;
        list+=index/8-2;
        list+=index%8;
        list+=index/8;
        PAWN_MOVES &= ~i;
        i= PAWN_MOVES & ~(PAWN_MOVES-1);

    }

    //capture right
    PAWN_MOVES = soEaOne(bpawns) & BBWhitePieces & ~whiteking;
    i = PAWN_MOVES &~ (PAWN_MOVES-1);

    while(i != 0){
        int index = trailingZeros(i);
        list+=index%8-1;
        list+=index/8-1;
        list+=index%8;
        list+=index/8;
        PAWN_MOVES &= ~i;
        i= PAWN_MOVES & ~(PAWN_MOVES-1);
    }


    //capture left
    PAWN_MOVES = soWeOne(bpawns) & BBWhitePieces & ~whiteking;
    i = PAWN_MOVES &~ (PAWN_MOVES-1);

    while(i != 0){
        int index = trailingZeros(i);
        list+=index%8+1;
        list+=index/8-1;
        list+=index%8;
        list+=index/8;
        PAWN_MOVES &= ~i;
        i= PAWN_MOVES & ~(PAWN_MOVES-1);
    }


//promotions
    PAWN_MOVES = southOne(bpawns) & EmptyTiles & rank1;
    i = PAWN_MOVES &~ (PAWN_MOVES-1);

    while(i != 0){
        int index = trailingZeros(i);
        list+=index%8;
        list+=index/8-1;
        list+='F';
        list+='Q';
        PAWN_MOVES &= ~i;
        i= PAWN_MOVES & ~(PAWN_MOVES-1);
    }


    //capture promotions
    //capture right
    PAWN_MOVES = soEaOne(bpawns) & BBWhitePieces & ~whiteking & rank1;
    i = PAWN_MOVES &~ (PAWN_MOVES-1);

    while(i != 0){
        int index = trailingZeros(i);
        list+=index%8-1;
        list+=index/8-1;
        list+=index%8;
        list+='Q';
        PAWN_MOVES &= ~i;
        i= PAWN_MOVES & ~(PAWN_MOVES-1);
    }


    //capture left
    PAWN_MOVES = soWeOne(bpawns) & BBWhitePieces & ~whiteking & rank1;
    i = PAWN_MOVES &~ (PAWN_MOVES-1);

    while(i != 0){
        int index = trailingZeros(i);
        list+=index%8+1;
        list+=index/8-1;
        list+=index%8;
        list+='Q';
        PAWN_MOVES &= ~i;
        i= PAWN_MOVES & ~(PAWN_MOVES-1);
    }

    return list;
}

//other piece moves
std::string moveGen::possibleN(U64 wOrBknights, U64 wOrBpieces, U64 oppositeking)
{
    std::string list;
    U64 moves;
    U64 i = wOrBknights & ~(wOrBknights-1);

    //loop through and find knights
    while(i != 0){
        int iLocation = trailingZeros(i);

        //use the knight span board which holds possible knight moves
        //and apply a shift to the knights current pos
        if(iLocation > 18){
            moves = KNIGHT_SPAN<<(iLocation-18);
        } else {
            moves = KNIGHT_SPAN>>(18-iLocation);
        }

        //making sure the moves don't wrap around to other side once shifter
        //as well as friendly and illegal king capture check
        if(iLocation % 8 < 4){
            moves &= ~FILE_GH & ~wOrBpieces & ~oppositeking;
        } else {
            moves &= ~FILE_AB & ~wOrBpieces & ~oppositeking;
        }

        U64 j = moves & ~(moves-1);

        while(j != 0){
            //store moves
            int index = trailingZeros(j);
            list+=iLocation%8;
            list+=iLocation/8;
            list+=index%8;
            list+=index/8;

            moves &= ~j;
            j = moves & ~(moves-1);
        }
        wOrBknights &= ~i;
        i = wOrBknights & ~(wOrBknights-1);
    }


    return list;
}

std::string moveGen::possibleB(U64 wOrBbishops, U64 wOrBpieces, U64 oppositeking)
{

    std::string list;
    U64 moves;
    U64 i = wOrBbishops & ~(wOrBbishops-1);

    while(i != 0){
        int iLocation = trailingZeros(i);
        moves =  DAndAntiDMoves(iLocation) & ~wOrBpieces & ~oppositeking;

        U64 j = moves & ~ (moves-1);

        while(j != 0){
            int index = trailingZeros(j);
            list+=iLocation%8;
            list+=iLocation/8;
            list+=index%8;
            list+=index/8;

            moves &= ~j;
            j = moves & ~(moves-1);
        }
        wOrBbishops &= ~i;
        i = wOrBbishops & ~(wOrBbishops-1);
    }

    return list;

}

std::string moveGen::possibleR(U64 wOrBrooks, U64 wOrBpieces, U64 oppositeking)
{
    std::string list;
    U64 moves;
    U64 i = wOrBrooks & ~(wOrBrooks-1);

    while(i != 0){
        int iLocation = trailingZeros(i);
        moves =  horizVert(iLocation) & ~wOrBpieces & ~oppositeking;

        U64 j = moves & ~ (moves-1);

        while(j != 0){
            int index = trailingZeros(j);
            list+=iLocation%8;
            list+=iLocation/8;
            list+=index%8;
            list+=index/8;

            moves &= ~j;
            j = moves & ~(moves-1);
        }
        wOrBrooks &= ~i;
        i = wOrBrooks & ~(wOrBrooks-1);
    }

    return list;
}

std::string moveGen::possibleQ(U64 wOrBqueens, U64 wOrBpieces, U64 oppositeking)
{
    std::string list;
    U64 moves;
    U64 i = wOrBqueens & ~(wOrBqueens-1);

    while(i != 0){
        int iLocation = trailingZeros(i);
        moves = (DAndAntiDMoves(iLocation) | horizVert(iLocation)) & ~wOrBpieces & ~oppositeking;

        U64 j = moves & ~ (moves-1);

        while(j != 0){
            int index = trailingZeros(j);
            list+=iLocation%8;
            list+=iLocation/8;
            list+=index%8;
            list+=index/8;

            moves &= ~j;
            j = moves & ~(moves-1);
        }
        wOrBqueens &= ~i;
        i = wOrBqueens & ~(wOrBqueens-1);
    }


    return list;
}

std::string moveGen::possibleK(U64 wOrBking, U64 wOrBpieces, U64 kingSafeLessKing)
{
    std::string list;
    U64 moves;

    //use safety of king board without king in it, so king can't move to a "safe" area
    // opposite a potential ray piece

    int i = trailingZeros(wOrBking);
    if(i > 9){
        moves = KING_SPAN << (i-9);

    } else {
        moves = KING_SPAN >> (9-i);
    }

    if(i % 8 < 4){
        moves &= ~FILE_GH & ~wOrBpieces;

    } else {
        moves &= ~FILE_AB & ~wOrBpieces;
    }
    //check king unsafe board against king moves
    //removing places the king would be unsafe from the moves
    moves &= ~kingSafeLessKing;

    U64 j = moves &~(moves-1);


    while(j != 0){
        int index = trailingZeros(j);

        list += i % 8;
        list += i / 8;
        list += index % 8;
        list += index / 8;

        moves &= ~j;
        j = moves &~ (moves-1);
    }

return list;

}

//implement into other MOVE GEN ASIDE FROM KINGS, MUCH FASTER THAN for 64 loop
int moveGen::trailingZeros(U64 i)
{
    //find the first one and number of zeros after it
    if (i == 0) return 64;
    U64 x = i;
    U64 y;
    int n = 63;
    y = x << 32; if (y != 0) { n -= 32; x = y; }
    y = x << 16; if (y != 0) { n -= 16; x = y; }
    y = x <<  8; if (y != 0) { n -=  8; x = y; }
    y = x <<  4; if (y != 0) { n -=  4; x = y; }
    y = x <<  2; if (y != 0) { n -=  2; x = y; }
    return (int) ( n - ((x << 1) >> 63));
}

U64 moveGen::horizVert(int s)
{
    //convert slider location to 64 bit binary
    U64 binaryS = 1LL << s;

    //left and right moves
    U64 possibilitiesHorizontal = (FullTiles - 2 * binaryS) ^ ReverseBits(ReverseBits(FullTiles) - 2 * ReverseBits(binaryS));
    //moves up and down
    U64 possibilitiesVertical = ((FullTiles & FileMasks8[s % 8]) - (2 * binaryS)) ^ ReverseBits(ReverseBits(FullTiles & FileMasks8[s % 8]) - (2 * ReverseBits(binaryS)));

    //NOTE need to & against friendlys. Incomplete mask of moves
    return (possibilitiesHorizontal & RankMasks8[s / 8]) | (possibilitiesVertical & FileMasks8[s % 8]);

}

U64 moveGen::DAndAntiDMoves(int s)
{
    U64 binaryS = 1LL <<s;

    U64 possibilitiesDiagonal = ((FullTiles & DiagonalMasks8[(s / 8) + (s % 8)]) - (2 * binaryS)) ^ ReverseBits(ReverseBits(FullTiles & DiagonalMasks8[(s / 8) + (s % 8)]) - (2 * ReverseBits(binaryS)));

    U64 possibilitiesAntiDiagonal = ((FullTiles & AntiDiagonalMasks8[(s / 8) + 7 - (s % 8)]) - (2 * binaryS)) ^ ReverseBits(ReverseBits(FullTiles & AntiDiagonalMasks8[(s / 8) + 7 - (s % 8)]) - (2 * ReverseBits(binaryS)));

    return (possibilitiesDiagonal & DiagonalMasks8[(s / 8) + (s % 8)]) | (possibilitiesAntiDiagonal & AntiDiagonalMasks8[(s / 8) + 7 - (s % 8)]);
}

U64 moveGen::ReverseBits(U64 input)
{
    //literally reverse bits in U64's
    U64 output = input;
    for (int i = sizeof(input) * 8-1; i; --i)
    {
        output <<= 1;
        input  >>= 1;
        output |=  input & 1;
    }
    return output;
}