#include "zobristh.h"
#include "externs.h"

#include <cmath>
#include <random>
#include <iostream>


std::random_device rd;

std::mt19937_64 mt(rd());

std::uniform_int_distribution<U64> dist(std::llround(std::pow(2,61)), std::llround(std::pow(2,62)));

U64 zArray[2][6][64];
//U64 zEnPassasnt[8]; ~~restore once implemented
//U64 zCastle[4];
U64 zBlackMove;

U64 zobKey;

ZobristH::ZobristH()
{

}

U64 ZobristH::random64()
{
    U64 ranUI = dist(mt);
    //std::cout << ranUI << ",   ";
    //long long int ranUI = rand();
    return ranUI;
}

void ZobristH::zobristFill()
{

    //fill zorbist array with random unisgned 64 bit ints
    for(int color = 0; color < 2; color++){
        for(int pieceType = 0; pieceType < 6; pieceType ++){
            for(int square = 0; square < 64; square ++){
                zArray[color][pieceType][square] = random64();
            }
        }

    }
    /*
    //enpassant and castle filling below

    for (int column = 0; column < 8; column++)
    {
        zEnPassant[column] = random64();
    }
    for (int i = 0; i < 4; i++)
    {
        zCastle[i] = random64();
    }
    */
    //random is it blacks turn or not
    zBlackMove = random64();
}

void ZobristH::updateKey(int start, int end, char captured)
{
    U64 s = 1LL << start;
    U64 e = 1LL << end;
    //if piece is white..
    if(BBWhitePieces & s) {
        if(BBWhitePawns & s){
            zobKey ^= zArray[0][0][start];
            zobKey ^= zArray[0][0][end];
        } else if(BBWhiteRooks & s){
            zobKey ^= zArray[0][1][start];
            zobKey ^= zArray[0][1][end];
        } else if(BBWhiteKnights & s){
            zobKey ^= zArray[0][2][start];
            zobKey ^= zArray[0][2][end];
        } else if(BBWhiteBishops & s){
            zobKey ^= zArray[0][3][start];
            zobKey ^= zArray[0][3][end];
        } else if(BBWhiteQueens & s){
            zobKey ^= zArray[0][4][start];
            zobKey ^= zArray[0][4][end];
        } else if(BBWhiteKing & s){
            zobKey ^= zArray[0][5][start];
            zobKey ^= zArray[0][5][end];
        }     
    } else if (BBBlackPieces & s){
        zobKey ^= zBlackMove;
        if(BBBlackPawns & s){
            zobKey ^= zArray[1][0][start];
            zobKey ^= zArray[1][0][end];
        } else if(BBBlackRooks & s){
            zobKey ^= zArray[1][1][start];
            zobKey ^= zArray[1][1][end];
        } else if(BBBlackKnights & s){
            zobKey ^= zArray[1][2][start];
            zobKey ^= zArray[1][2][end];
        } else if(BBBlackBishops & s){
            zobKey ^= zArray[1][3][start];
            zobKey ^= zArray[1][3][end];
        } else if(BBBlackQueens & s){
            zobKey ^= zArray[1][4][start];
            zobKey ^= zArray[1][4][end];
        } else if(BBBlackKing & s){
            zobKey ^= zArray[1][5][start];
            zobKey ^= zArray[1][5][end];
        } 
        
    }  
    
    if(captured != '0' || captured != 0){
        
    }
    
    
    zobKey ^= zBlackMove;
}

U64 ZobristH::getZobristHash(bool isWhiteTurn)
{
    U64 returnZKey = 0LL;
    for (int square = 0; square < 64; square++){
        //if tile is empty skip all the rest of the if statments
        if(((EmptyTiles >> square) & 1) == 1){
            continue;
        }
        //white and black pawns
        //if there is a white pawn on i square
        if(((BBWhitePawns >> square) & 1) == 1)
        {
            //XOR the zkey with the U64 in the white pawns square
            //that was generated from rand64
            returnZKey ^= zArray[0][0][square];
        }
        else if(((BBBlackPawns >> square) & 1) == 1)
        {
            returnZKey ^= zArray[1][0][square];
        }
        //white pieces
        else if(((BBWhiteRooks >> square) & 1) == 1)
        {
            returnZKey ^= zArray[0][1][square];
        }
        else if(((BBWhiteKnights >> square) & 1) == 1)
        {
            returnZKey ^= zArray[0][2][square];
        }
        else if(((BBWhiteBishops >> square) & 1) == 1)
        {
            returnZKey ^= zArray[0][3][square];
        }
        else if(((BBWhiteQueens >> square) & 1) == 1)
        {
            returnZKey ^= zArray[0][4][square];
        }
        else if(((BBWhiteKing >> square) & 1) == 1)
        {
            returnZKey ^= zArray[0][5][square];
        }

        //black pieces
        else if(((BBBlackRooks >> square) & 1) == 1)
        {
            returnZKey ^= zArray[1][1][square];
        }
        else if(((BBBlackKnights >> square) & 1) == 1)
        {
            returnZKey ^= zArray[1][2][square];
        }
        else if(((BBBlackBishops >> square) & 1) == 1)
        {
            returnZKey ^= zArray[1][3][square];
        }
        else if(((BBBlackQueens >> square) & 1) == 1)
        {
            returnZKey ^= zArray[1][4][square];
        }
        else if(((BBBlackKing >> square) & 1) == 1)
        {
            returnZKey ^= zArray[1][5][square];
        }
    }
    //EnPassant and castling stuff

    //if it isn't whites turn, XOR zobrist key with black move U64
    if(!isWhiteTurn){
        returnZKey ^= zBlackMove;
    }

    zobKey = returnZKey;
    
    return returnZKey;
}



void ZobristH::testDistibution()
{
    const int sampleSize = 2000;
    int distArray[sampleSize] = {};
    int t = 0;
    while (t < 1500)
    {
       for (int i = 0; i < 2000; i++)
       {
           distArray[(int)(random64() % sampleSize)]++;
       }
       t++;
    }
    for (int i = 0; i < sampleSize; i++)
    {
        std::cout << distArray[i] << std::endl;
    }

}




























